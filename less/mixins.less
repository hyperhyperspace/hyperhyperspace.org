.has(@attribute) {
  @{attribute}: @@attribute;
}

.contrast-fill-against(@color: @background; @contrast-standard: 7; @mode: auto;) {
  // adds tone to background color until contrast standard is met
  // uses result as fill color

  @start: 0%;
  @iterations: 33;
  @index: 0;	

  .contrast-fill(@contrast-ratio, @tone, @index)
      when (@contrast-ratio < @contrast-standard)
      and (@index < @iterations) {
      .set-contrast-ratio(@color, mix(@tone, @color, @start + @index*3));
      .contrast-fill(@contrast-ratio; @tone; @index + 1);
  }

  .contrast-fill(@contrast-ratio, @tone, @index) when (default()) {
      @fill: mix(@tone, @color, @start + @index*3);
  }

  .set-tone(@color);
  .contrast-fill(1, @tone, 1);
}

.invert-text-against(@color; @contrast-standard: 7; @button: false;) {
	// always results in white text
	// darkens given background when needed to meet contrast standard

	@iterations: 10;

	.set-contrast-ratio(@color, white);
	.darken-bg(@color, @contrast-ratio, 1);

	.darken-bg(@bg-color, @contrast-ratio, @index)
	   when (@contrast-ratio < 4.5)
		and (@index < @iterations) {
		@new-bg-color: darken(@bg-color, 5% + @index);
		.set-contrast-ratio(white, @new-bg-color);
		.darken-bg(@new-bg-color, @contrast-ratio, @index + 1);
	}

	.darken-bg(@bg-color, @contrast-ratio, @index) when (default()) {
  background-color: @bg-color;
	color: white;

		& when (@button = true) {
			// button option lets us handle active state here when we know the color
			&:active {
        background-color: darken(@bg-color, 5%);        
				// color: mix(@bg-color, black, 5%);
			}
		}
	}
}

.color-text(@color: @action; @text-background: @background; @contrast-standard: 4.5) {

  // colors text against a background

  @iterations: 40;

  .set-contrast-ratio(@color, @text-background);
  .set-tone(@text-background);
  .adjust-text(@contrast-ratio, 1);

  .adjust-text(@contrast-ratio, @index)
		     when (@contrast-ratio < @contrast-standard)
		      and (@index < @iterations) {

    @new-text-color: mix(@tone, @color, 2.5%*@index);

	  .set-contrast-ratio(@text-background, @new-text-color);
	  .adjust-text(@contrast-ratio, @index + 1);
  }

  .adjust-text(@contrast-ratio, @index) when (default()) {
	  color: mix(@tone, @color, 2.5%*@index);
  }
}

.colorize(@color; @contrast-standard: 7;) {
  // sets a background color and makes sure text works with it
  background-color: @color;
  // .blueprint(@color);
  .contrast-text-against(@color; @contrast-standard;);

}

.contrast-text-against(@color: @background; @contrast-standard: 7; @mode: auto;) {
	// adds tone to background color until contrast standard is met
	// uses result as text color

	@start: 50%;
	@iterations: 10;
	@contrast: mix(@tone, @color, @start + @index*5);
	@index: 0;

	.tone(@color);
	.contrast-text(1, @tone, 1);

	.tone(@color) when (@mode = tint) {
		@tone: white;
	}

	.tone(@color) when (@mode = shade) {
		@tone: black;
	}

	.tone(@color) when (default()) {
		.set-tone(@color);
	}

	.contrast-text(@contrast-ratio, @tone, @index)
	   when (@contrast-ratio < @contrast-standard)
		and (@index < @iterations) {
		.set-contrast-ratio(@color, @contrast);
		.contrast-text(@contrast-ratio; @tone; @index + 1);
	}

	.contrast-text(@contrast-ratio, @tone, @index) when (default()) {
		color: @contrast;
	}
}


.contrast-border-against(@color: @background; @contrast-standard: 7; @mode: auto;) {
	// adds tone to background color until contrast standard is met
	// uses result as border color

	@start: 50%;
	@iterations: 10;
	@contrast: mix(@tone, @color, @start + @index*5);
	@index: 0;

	.tone(@color);
	.contrast-border(1, @tone, 1);

	.tone(@color) when (@mode = tint) {
		@tone: white;
	}

	.tone(@color) when (@mode = shade) {
		@tone: black;
	}

	.tone(@color) when (default()) {
		.set-tone(@color);
	}

	.contrast-border(@contrast-ratio, @tone, @index)
	   when (@contrast-ratio < @contrast-standard)
		and (@index < @iterations) {
		.set-contrast-ratio(@color, @contrast);
		.contrast-border(@contrast-ratio; @tone; @index + 1);
	}

	.contrast-border(@contrast-ratio, @tone, @index) when (default()) {
		border-color: @contrast;
	}
}

.set-contrast-ratio(@a, @b) when (luma(@a) > luma(@b)) {
  // sets variable @contrast-ratio to contrast ratio between two colors

  @l1: unit(luma(@a))/100;
  @l2: unit(luma(@b))/100;
  @contrast-ratio: round((@l1 + .05)/(@l2 + .05),2);
}

.set-contrast-ratio(@a, @b) when (luma(@b) > luma(@a)) {
  @l1: unit(luma(@b))/100;
  @l2: unit(luma(@a))/100;
  @contrast-ratio: round((@l1 + .05)/(@l2 + .05),2);
}

.set-contrast-ratio(@a, @b) when (luma(@b) = luma(@a)) {
  @contrast-ratio: 1;
}

.set-distance(@a, @b) {
  // sets variable @distance to distance between two colors
  // distance is RGB space units

  // RGB space model isn't perfectly cubic, but instead
  // adjusted for human perception

  @r-values-a-b: 2*(red(@b) - red(@a))*(red(@b) - red(@a));
  @g-values-a-b: 4*(green(@b) - green(@a))*(green(@b) - green(@a));
  @b-values-a-b: 3*(blue(@b) - blue(@a))*(blue(@b) - blue(@a));

  @distance: round((sqrt(@r-values-a-b + @g-values-a-b + @b-values-a-b)),2);
}

.set-closer-farther-hue(@compare, @c1, @c2) {
  // compares c1 and c2 to a given color, assigns a @farther and @closer
  // comparison is hue

  .set-difference-m-c1() {
	  @difference-m-c1: abs(hue(@compare) - hue(@c1));
  }

  .set-difference-m-c2() {
	  @difference-m-c2: abs(hue(@compare) - hue(@c2));
  }

  .resolve() when (@difference-m-c2 > @difference-m-c1) {
	  @farther: @c2;
	  @closer: @c1;
  }

  .resolve() when (default()) {
	  @farther: @c1;
	  @closer: @c2;
  }

  .set-difference-m-c1();
  .set-difference-m-c2();

  .resolve();
}

.set-closer-farther(@compare, @c1, @c2) {
  // compares c1 and c2 to a given color, assigns a @farther and @closer
  // distance is RGB space units

  .set-distance-m-c1() {
    .set-distance(@compare, @c1);
    @distance-m-c1: @distance;
  }

  .set-distance-m-c2() {
    .set-distance(@compare, @c2);
    @distance-m-c2: @distance;
  }

  .resolve() when (@distance-m-c2 > @distance-m-c1) {
    @farther: @c2;
    @closer: @c1;
  }

  .resolve() when (default()) {
    @farther: @c1;
    @closer: @c2;
  }

  .set-distance-m-c1();
  .set-distance-m-c2();

  .resolve();
}

.set-farther-closer(@compare, @c1, @c2) {
  // just another closer-farther
  .set-closer-farther(@compare, @c1, @c2);
}

.set-tone(@color) {
  // sets variable @tone to white or black, depending on which is better for text contrast

  .set-contrast-ratio-black() {
    .set-contrast-ratio(@color, black);
    @contrast-ratio-black: @contrast-ratio;
  }

  .set-contrast-ratio-white() {
    .set-contrast-ratio(@color, white);
    @contrast-ratio-white: @contrast-ratio;
  }

  .set-tone(@color) when (@contrast-ratio-black > @contrast-ratio-white) {
    @tone: black;
  }

  .set-tone(@color) when (default()) {
    @tone: white;
  }

  .set-contrast-ratio-black();
  .set-contrast-ratio-white();

  .set-tone(@color);
}

.set-average(@colors) {
  // averages a list of colors
  // sets result to @average

  @iterations: length(@colors);

  .find-average(extract(@colors, 1), 1);

  .find-average(@color, @index) when (@index <= @iterations) {
    @this-color: extract(@colors, @index);
    @last-color: @color;
    @weight: 100% * (1/@index);
    @new-average: mix(@this-color, @last-color, @weight);

    .find-average(@new-average, @index + 1);
  }

  .find-average(@color, @index) when (default()) {
    @average: @color;
  }
}

.set-lumafix(@color; @compare: @base-color; @strength: 100%;) {
  // sets @lumafix to a version of @color with luma similar to @compare

  @iterations: 24;

  // .settings() keeps lumafix from flipping back and forth 
  // between shading and tinting

  .settings() when (luma(@color) > luma(@compare)) {
	@tone: black;
  }

  .settings() when (luma(@compare) >= luma(@color)) {
	@tone: white;
  }

  .lumafix(@color-to-fix, @compare, @index) when (@index <= @iterations)
									  and (luma(@color-to-fix) < luma(@compare))
									  and (@tone = white) {
	@new-color: lighten(@color-to-fix, .5%*@index);
	.lumafix(@new-color, @compare, @index + 1);
  }

  .lumafix(@color-to-fix, @compare, @index) when (@index <= @iterations)
									  and (luma(@color-to-fix) > luma(@compare))
									  and (@tone = black) {
	@new-color: darken(@color-to-fix, .5%*@index);
	.lumafix(@new-color, @compare, @index + 1);
  }

  .lumafix(@color-to-fix, @compare, @index) when (default()) {
	@lumafix: mix(@color, @color-to-fix, (100% - @strength));
  }

  .settings();
  .lumafix(@color, @compare, 1);
}

.no-user-select() {
  -moz-user-select: -moz-none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -ms-user-select: none;
}

.hide() {
  &:extend(.hide);
}

.clearfix() {
  clear: both;
  &:after {
    display: block;
    clear: both;
    content: "";
  }
}

.semantic-block-padding() {
  .semantic-classes({
    // this needs padding when it has a color background
    .has(padding);
  });
}